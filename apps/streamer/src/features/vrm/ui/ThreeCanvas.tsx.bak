import { useCallback, useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
import { VRM, VRMUtils, VRMLoaderPlugin, VRMHumanoid } from "@pixiv/three-vrm";
import * as Kalidokit from "kalidokit";
import * as poseDetection from "@tensorflow-models/pose-detection";
import * as tf from "@tensorflow/tfjs-core";
import "@tensorflow/tfjs-backend-webgl";

interface ThreeCanvasProps {
  vrmUrl: string | null;
  isCameraEnabled: boolean;
  selectedDevice: MediaDeviceInfo | null;
  onCanvasReady: (canvas: HTMLCanvasElement) => void;
  isVisible: boolean;
  width: number;
  height: number;
}

// Animate Rotation Helper function
const rigRotation = (
  vrm: VRM,
  name: keyof VRMHumanoid["humanBones"],
  rotation = { x: 0, y: 0, z: 0 },
  dampener = 1,
  lerpAmount = 0.3
) => {
  if (!vrm.humanoid) return;

  const Part = vrm.humanoid.getNormalizedBoneNode(name);
  if (!Part) return;

  const euler = new THREE.Euler(
    rotation.x * dampener,
    rotation.y * dampener,
    rotation.z * dampener,
    "XYZ"
  );
  const quaternion = new THREE.Quaternion().setFromEuler(euler);
  Part.quaternion.slerp(quaternion, lerpAmount);
};

// Animate Position Helper Function
const rigPosition = (
  vrm: VRM,
  name: keyof VRMHumanoid["humanBones"],
  position = { x: 0, y: 0, z: 0 },
  dampener = 1,
  lerpAmount = 0.3
) => {
  if (!vrm.humanoid) return;

  const Part = vrm.humanoid.getNormalizedBoneNode(name);
  if (!Part) return;

  const vector = new THREE.Vector3(
    position.x * dampener,
    position.y * dampener,
    position.z * dampener
  );
  Part.position.lerp(vector, lerpAmount);
};

const ThreeCanvas = ({
  vrmUrl,
  isCameraEnabled,
  selectedDevice,
  onCanvasReady,
  isVisible,
  width,
  height,
}: ThreeCanvasProps) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const currentVrm = useRef<VRM | null>(null);
  const poseDetectorRef = useRef<poseDetection.PoseDetector | null>(null);
  const oldLookTarget = useRef(new THREE.Euler());

  useEffect(() => {
    if (currentVrm.current) {
      currentVrm.current.scene.visible = isVisible;
    }
  }, [isVisible]);


  const animateVRMWithBlazePose = useCallback(
    (vrm: VRM, blazePoseResult: poseDetection.Pose | null) => {
      if (!currentVrm.current || !blazePoseResult) return;

      const videoElement = videoRef.current;
      if (!videoElement) return;

      try {
        const worldLandmarks = blazePoseResult.keypoints3D;
        const landmarks2D = blazePoseResult.keypoints;

        if (!worldLandmarks || !landmarks2D) {
          console.warn("[BlazePose] landmarks 없음");
          return;
        }

        console.log("[BlazePose] World landmark 샘플:", worldLandmarks[0]);

        const riggedPose = Kalidokit.Pose.solve(worldLandmarks, landmarks2D, {
          runtime: "tfjs",
          video: videoElement,
        });
        if (riggedPose) {
          console.log("[BlazePose] Rigged pose 성공:", riggedPose.Hips);

          rigRotation(vrm, "hips", riggedPose.Hips.rotation, 0.3);
          rigPosition(
            vrm,
            "hips",
            {
              x: -riggedPose.Hips.position.x,
              y: riggedPose.Hips.position.y + 1,
              z: -riggedPose.Hips.position.z,
            },
            1,
            0.07
          );

          rigRotation(vrm, "chest", riggedPose.Spine, 0.25, 0.3);
          rigRotation(vrm, "spine", riggedPose.Spine, 0.45, 0.3);
          rigRotation(vrm, "rightUpperArm", riggedPose.RightUpperArm, 1, 0.3);
          rigRotation(vrm, "rightLowerArm", riggedPose.RightLowerArm, 1, 0.3);
          rigRotation(vrm, "leftUpperArm", riggedPose.LeftUpperArm, 1, 0.3);
          rigRotation(vrm, "leftLowerArm", riggedPose.LeftLowerArm, 1, 0.3);
          rigRotation(vrm, "leftUpperLeg", riggedPose.LeftUpperLeg, 1, 0.3);
          rigRotation(vrm, "leftLowerLeg", riggedPose.LeftLowerLeg, 1, 0.3);
          rigRotation(vrm, "rightUpperLeg", riggedPose.RightUpperLeg, 1, 0.3);
          rigRotation(vrm, "rightLowerLeg", riggedPose.RightLowerLeg, 1, 0.3);
        }
      } catch (error) {
        console.error("[BlazePose] VRM 애니메이션 에러:", error);
      }
    },
    []
  );

  useEffect(() => {
    if (!isCameraEnabled || !videoRef.current) return;

    const videoElement = videoRef.current;
    let animationFrameId: number | undefined;

    const setupCamera = async () => {
      try {
        const videoConstrains: MediaTrackConstraints = {
          width: 640,
          height: 480,
        };
        if (selectedDevice) {
          videoConstrains.deviceId = { exact: selectedDevice.deviceId };
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstrains,
          audio: false,
        });
        videoElement.srcObject = stream;
        await videoElement.play();
        console.log("[BlazePose] 카메라 설정 완료");
      } catch (error) {
        console.error("[BlazePose] 카메라 접근 실패:", error);
        alert("카메라 접근에 실패했습니다. 카메라 권한을 확인해주세요.");
      }
    };

    const initializeBlazePose = async () => {
      await setupCamera();

      console.log("[BlazePose] TensorFlow 초기화 시작...");
      await tf.ready();
      await tf.setBackend("webgl");
      console.log("[BlazePose] 백엔드:", tf.getBackend());

      console.log("[BlazePose] 디텍터 생성 중...");
      const detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.BlazePose,
        {
          runtime: "tfjs",
          modelType: "lite",
          enableSmoothing: true,
          enableSegmentation: false,
        }
      );
      poseDetectorRef.current = detector;
      console.log("[BlazePose] 디텍터 초기화 완료");

      const detectPose = async () => {
        if (videoElement.readyState >= 2 && poseDetectorRef.current && currentVrm.current) {
          try {
            const poses = await poseDetectorRef.current.estimatePoses(videoElement, {
              flipHorizontal: false,
            });

            if (poses.length > 0) {
              animateVRMWithBlazePose(currentVrm.current, poses[0]);
            }
          } catch (error) {
            console.error("[BlazePose] 감지 에러:", error);
          }
        }
        animationFrameId = requestAnimationFrame(detectPose);
      };

      detectPose();
    };

    initializeBlazePose();

    return () => {
      if (animationFrameId !== undefined) {
        cancelAnimationFrame(animationFrameId);
      }
      if (poseDetectorRef.current) {
        poseDetectorRef.current.dispose();
        poseDetectorRef.current = null;
      }
      const stream = videoElement.srcObject as MediaStream;
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
      }
    };
  }, [animateVRMWithBlazePose, isCameraEnabled, selectedDevice]);

  const OLD_HOLISTIC_CODE_BELOW = () => {
    return;
    if (leftHandLandmarks) {
              riggedLeftHand = Kalidokit.Hand.solve(leftHandLandmarks, "Left");
              if (riggedLeftHand) {
                rigRotation(vrm, "leftHand", {
                  z: riggedPose.LeftHand.z,
                  y: riggedLeftHand.LeftWrist.y,
                  x: riggedLeftHand.LeftWrist.x,
                });
                rigRotation(
                  vrm,
                  "leftRingProximal",
                  riggedLeftHand.LeftRingProximal
                );
                rigRotation(
                  vrm,
                  "leftRingIntermediate",
                  riggedLeftHand.LeftRingIntermediate
                );
                rigRotation(
                  vrm,
                  "leftRingDistal",
                  riggedLeftHand.LeftRingDistal
                );
                rigRotation(
                  vrm,
                  "leftIndexProximal",
                  riggedLeftHand.LeftIndexProximal
                );
                rigRotation(
                  vrm,
                  "leftIndexIntermediate",
                  riggedLeftHand.LeftIndexIntermediate
                );
                rigRotation(
                  vrm,
                  "leftIndexDistal",
                  riggedLeftHand.LeftIndexDistal
                );
                rigRotation(
                  vrm,
                  "leftMiddleProximal",
                  riggedLeftHand.LeftMiddleProximal
                );
                rigRotation(
                  vrm,
                  "leftMiddleIntermediate",
                  riggedLeftHand.LeftMiddleIntermediate
                );
                rigRotation(
                  vrm,
                  "leftMiddleDistal",
                  riggedLeftHand.LeftMiddleDistal
                );
                rigRotation(
                  vrm,
                  "leftThumbProximal",
                  riggedLeftHand.LeftThumbProximal
                );
                rigRotation(
                  vrm,
                  "leftThumbDistal",
                  riggedLeftHand.LeftThumbDistal
                );
                rigRotation(
                  vrm,
                  "leftLittleProximal",
                  riggedLeftHand.LeftLittleProximal
                );
                rigRotation(
                  vrm,
                  "leftLittleIntermediate",
                  riggedLeftHand.LeftLittleIntermediate
                );
                rigRotation(
                  vrm,
                  "leftLittleDistal",
                  riggedLeftHand.LeftLittleDistal
                );
              }
            }
            if (rightHandLandmarks) {
              riggedRightHand = Kalidokit.Hand.solve(
                rightHandLandmarks,
                "Right"
              );
              if (riggedRightHand) {
                rigRotation(vrm, "rightHand", {
                  z: riggedPose.RightHand.z,
                  y: riggedRightHand.RightWrist.y,
                  x: riggedRightHand.RightWrist.x,
                });
                rigRotation(
                  vrm,
                  "rightRingProximal",
                  riggedRightHand.RightRingProximal
                );
                rigRotation(
                  vrm,
                  "rightRingIntermediate",
                  riggedRightHand.RightRingIntermediate
                );
                rigRotation(
                  vrm,
                  "rightRingDistal",
                  riggedRightHand.RightRingDistal
                );
                rigRotation(
                  vrm,
                  "rightIndexProximal",
                  riggedRightHand.RightIndexProximal
                );
                rigRotation(
                  vrm,
                  "rightIndexIntermediate",
                  riggedRightHand.RightIndexIntermediate
                );
                rigRotation(
                  vrm,
                  "rightIndexDistal",
                  riggedRightHand.RightIndexDistal
                );
                rigRotation(
                  vrm,
                  "rightMiddleProximal",
                  riggedRightHand.RightMiddleProximal
                );
                rigRotation(
                  vrm,
                  "rightMiddleIntermediate",
                  riggedRightHand.RightMiddleIntermediate
                );
                rigRotation(
                  vrm,
                  "rightMiddleDistal",
                  riggedRightHand.RightMiddleDistal
                );
                rigRotation(
                  vrm,
                  "rightThumbProximal",
                  riggedRightHand.RightThumbProximal
                );
                rigRotation(
                  vrm,
                  "rightThumbDistal",
                  riggedRightHand.RightThumbDistal
                );
                rigRotation(
                  vrm,
                  "rightLittleProximal",
                  riggedRightHand.RightLittleProximal
                );
                rigRotation(
                  vrm,
                  "rightLittleIntermediate",
                  riggedRightHand.RightLittleIntermediate
                );
                rigRotation(
                  vrm,
                  "rightLittleDistal",
                  riggedRightHand.RightLittleDistal
                );
              }
            }
          }
        }
      } catch (error) {
        console.error("Kalidokit solve error:", error);
      }
    },
    [rigFace]
  );


  useEffect(() => {
    if (width === 0 || height === 0) return;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30.0, width / height, 0.1, 20.0);
    camera.position.set(0.0, 1.4, 1.5);

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    onCanvasReady(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(1.0, 1.0, 1.0).normalize();
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));

    const clock = new THREE.Clock();
    let animationFrameId: number;

    const urlToLoad =
      vrmUrl || "https://d1l5n2avb89axj.cloudfront.net/avatar-first.vrm";

    if (urlToLoad) {
      loader.load(
        urlToLoad,
        (gltf) => {
          const vrm = gltf.userData.vrm;
          if (currentVrm.current) {
            scene.remove(currentVrm.current.scene);
            VRMUtils.deepDispose(currentVrm.current.scene);
          }
          scene.add(vrm.scene);
          vrm.scene.rotation.y = Math.PI;
          vrm.scene.visible = isVisible;
          currentVrm.current = vrm;

          // VRM 모델의 밝기 조정
          vrm.scene.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              if (Array.isArray(child.material)) {
                child.material = child.material.map((mat) => mat.clone());
              } else {
                child.material = child.material.clone();
              }

              if (Array.isArray(child.material)) {
                child.material.forEach((mat) => {
                  if (mat instanceof THREE.MeshStandardMaterial) {
                    mat.emissiveIntensity = 0.2;
                    mat.envMapIntensity = 0.6;
                  }
                });
              } else if (child.material instanceof THREE.MeshStandardMaterial) {
                child.material.emissiveIntensity = 0.2;
                child.material.envMapIntensity = 0.6;
              }
            }
          });

          if (vrm.lookAt) {
            vrm.lookAt.target = new THREE.Object3D();
            vrm.scene.add(vrm.lookAt.target);
          }
        },
        undefined,
        (error) => {
          console.error("[VRM] 로드 실패:", error);
        }
      );
    }

    const animate = () => {
      animationFrameId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (currentVrm.current) {
        currentVrm.current.update(delta);
      }
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      cancelAnimationFrame(animationFrameId);
      if (currentVrm.current) {
        VRMUtils.deepDispose(currentVrm.current.scene);
      }
      renderer.dispose();
    };
  }, [height, onCanvasReady, vrmUrl, width]);

  return <video ref={videoRef} style={{ display: "none" }}></video>;
};

export default ThreeCanvas;
